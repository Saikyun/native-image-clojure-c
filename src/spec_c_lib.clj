;; 1. take a c prototype
;; 2. generate data as below
;; 3. generate c shadowing function
;; 4. generate clojure polyglot code
;; 5. generate clojure ni code

(ns spec-c-lib
  (:require [clojure.string :as str]
            [clojure.java.shell :refer [sh]]
            [clojure.java.io :as io]
            
            [gen-c :as gcee]
            [gen-clj :as gclj]
            [gen-clj.polyglot :as poly]
            
            [clojure.pprint :refer [pp pprint]]))

(defn shadow-data
  [f]
  (update f :sym #(str "_SHADOWING_" %)))

(defn gen-both
  [lib-name {:keys [includes protos inline-c] :as opts}]
  (let [c-file (gcee/gen-c-file [(str (:c-name opts) ".h")]
                                (map gcee/generate-shadowing-function protos)
                                opts)
        
        protos-as-data-shadowed (map shadow-data protos)
        
        h-file (gcee/gen-h-file includes
                                (map gcee/generate-c-prototype protos-as-data-shadowed))
        
        clojure-lib (poly/gen-lib lib-name (concat
                                            (map #(gclj/gen-clojure-mapping % {:prefixes ["_SHADOWING_SDL"
                                                                                          "_SHADOWING_"]})
                                                 protos-as-data-shadowed))
                                  opts)]
    {:c-code c-file
     :h-code h-file
     :clojure-lib clojure-lib
     :opts (assoc opts :lib-name lib-name)}))

(defn compile-c
  [{:keys [c-code h-code opts]}]
  (spit (:c-path opts) c-code)
  (spit (:h-path opts) h-code)
  (let [sh-opts (concat [(str (System/getenv "LLVM_TOOLCHAIN") "/clang") (:c-path opts)]
                        (map #(str "-l" %) (:libs opts))
                        ["-shared" "-fPIC" "-o" (:bc-path opts)])]
    (apply sh sh-opts)))

(defn persist-c
  [res]
  (let [{:keys [err]} (compile-c res)]
    (when (seq err) 
      (println "ERROR:" err)
      (println "Compilation failed:" res)
      (throw (Error. err)))))

(defn persist-clj
  [res]
  (with-open [wrtr (io/writer (str (:clojure-src (:opts res))
                                   "/"
                                   (str/replace (str (:lib-name (:opts res))) "." "/") ".clj"))]
    (.write wrtr ";; This file is autogenerated -- probably shouldn't modify it by hand\n")
    (.write wrtr
            (with-out-str (doseq [f (:clojure-lib res)]
                            (pprint f)
                            (print "\n"))))))

(defn gen-and-persist
  "Takes a lib name as symbol and options required to generate c and clojure code.
  Example call:
  (scl/gen-and-persist
  'c.sdl
  {:protos [(parse-c-prototype \"int SDL_Init(Uint32 flags)\")     ;; c style prototye
           {:ret \"void\", :sym \"SDL_Quit\"}]                     ;; prototype as data
  :includes [\"stdio.h\" \"SDL2/SDL.h\"]
  :c-path \"src/generated.c\"
  :bc-path \"libs/generated.bc\"
  :clojure-src \"src\"
  :libs [\"SDL2\"]})
  "
  [lib-name opts]
  (let [{:keys [opts] :as res} (gen-both lib-name opts)]
    (if (:skip-c-gen opts)
      (println ":skip-c true, no c-code generated.")
      (persist-c res))
    (persist-clj res)
    lib-name))

(comment
  
  (pprint (parse-c-prototype "int SDL_Init(Uint32 flags, a * b, const c d)"))
  
  (pprint (parse-c-prototype "void SDL_Quit()"))
  (pprint (parse-c-prototype "int* SDL_Init(Uint32 flags, a * b, c d)"))
  
  (-> (parse-c-prototype "int* SDL_Init(Uint32 flags, a * b, c d)")
      generate-shadowing-function
      println)
  
  (-> (parse-c-prototype "int* SDL_Init(Uint32 flags, a * b, c d)")
      (gen-clojure-mapping {:prefixes ["SDL_"]})
      println)
  
  
  
  {'SDLEvent {:type "SDL_Event"}
   
   ;; int SDL_Init(Uint32 flags)
   'init {:ret 'int
          :sym "SDL_Init"
          :args [{:type "Uint32"
                  :sym "flags"}]}
   
   ;; int SDL_PollEvent(SDL_Event* event)
   'poll-event {:ret 'int
                :sym "SDL_PollEvent"
                :args [{:type "SDL_Event"
                        :pointer "*"
                        :sym "event"}]}})
